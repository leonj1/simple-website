name: Semantic Version and Tag

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: read

jobs:
  version-and-tag:
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.version.outputs.new_tag }}
      new_version: ${{ steps.version.outputs.new_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper version calculation

      - name: Get next version
        id: version
        uses: mathieudutour/github-tag-action@v6.2
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          dry_run: true  # Don't create tag yet, just calculate version
          default_bump: patch
          tag_prefix: v
          # Analyze commit messages for version bumping
          # feat: minor bump
          # fix: patch bump  
          # BREAKING CHANGE: major bump
          release_branches: main
          pre_release_branches: '^((dev|develop|staging|beta|preview)/.*)$'
          custom_release_rules: |
            chore:patch,
            docs:patch,
            style:patch,
            refactor:patch,
            perf:patch,
            test:patch,
            build:patch,
            ci:patch

      - name: Check if this is first release
        id: check_previous_tag
        run: |
          if [ -z "${{ steps.version.outputs.previous_tag }}" ]; then
            echo "is_first_release=true" >> $GITHUB_OUTPUT
          else
            echo "is_first_release=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog from commits
        id: changelog
        if: steps.check_previous_tag.outputs.is_first_release == 'false'
        run: |
          PREVIOUS_TAG="${{ steps.version.outputs.previous_tag }}"
          CHANGELOG=""
          
          # Get commit messages between previous tag and HEAD
          while IFS= read -r commit; do
            if [[ -n "$commit" ]]; then
              CHANGELOG="${CHANGELOG}- ${commit}"$'\n'
            fi
          done < <(git log "${PREVIOUS_TAG}..HEAD" --pretty=format:"%s" --reverse)
          
          # Set multiline output
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Get commits for first release
        id: first_release_commits
        if: steps.check_previous_tag.outputs.is_first_release == 'true'
        run: |
          COMMITS=$(git log --pretty=format:"- %s" --reverse)
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create and push tag
        if: steps.version.outputs.new_tag
        uses: mathieudutour/github-tag-action@v6.2
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          custom_tag: ${{ steps.version.outputs.new_tag }}
          tag_prefix: v

      - name: Create Release
        if: steps.version.outputs.new_tag
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.version.outputs.new_tag }}
          name: Release ${{ steps.version.outputs.new_tag }}
          body: |
            ## What's Changed
            ${{ steps.check_previous_tag.outputs.is_first_release == 'true' && steps.first_release_commits.outputs.commits || steps.changelog.outputs.changelog }}
            
            ${{ steps.check_previous_tag.outputs.is_first_release == 'false' && format('**Full Changelog**: https://github.com/{0}/compare/{1}...{2}', github.repository, steps.version.outputs.previous_tag, steps.version.outputs.new_tag) || '**Initial Release**' }}
          makeLatest: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update package.json version (if exists)
        if: steps.version.outputs.new_tag
        run: |
          if [ -f "package.json" ]; then
            VERSION="${{ steps.version.outputs.new_version }}"
            jq --arg version "$VERSION" '.version = $version' package.json > package.json.tmp
            mv package.json.tmp package.json
            
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            git add package.json
            git commit -m "chore: bump version to ${{ steps.version.outputs.new_tag }} [skip ci]"
            git push origin main
          fi

  create-zip-artifact:
    needs: version-and-tag
    runs-on: ubuntu-latest
    if: needs.version-and-tag.outputs.new_tag
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create zip artifact
        run: |
          VERSION="${{ needs.version-and-tag.outputs.new_tag }}"
          echo "Creating zip artifact with version: $VERSION"
          
          # Check if Dockerfile.zip exists
          if [ ! -f "Dockerfile.zip" ]; then
            echo "Dockerfile.zip not found. Creating it..."
            cat > Dockerfile.zip << 'EOF'
FROM alpine:latest

# Install zip
RUN apk add --no-cache zip

# Accept version as build arg
ARG VERSION=latest
ENV VERSION=${VERSION}

# Set working directory
WORKDIR /workspace

# Copy project files (excluding unwanted files)
COPY . .

# Create zip file with version in filename
CMD sh -c "zip -r /output/dark-theme-landing-${VERSION}.zip . \
     -x 'node_modules/*' \
     -x 'build/*' \
     -x '*.zip' \
     -x '.git/*' \
     -x '.gitignore' \
     -x '*.log' \
     -x '.DS_Store' \
     -x 'Dockerfile.zip'"
EOF
          fi
          
          make docker-zip VERSION=$VERSION

      - name: Upload artifact to release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.version-and-tag.outputs.new_tag }}
          artifacts: "dark-theme-landing-${{ needs.version-and-tag.outputs.new_tag }}.zip"
          artifactContentType: application/zip
          allowUpdates: true
          omitBody: true
          omitName: true
          token: ${{ secrets.GITHUB_TOKEN }}